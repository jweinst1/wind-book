
% commands chapter
\chapter{Commands}

\paragraph{  } In Wind, all computation is initiated and encapsulated inside commands. Wind's stream-like syntax eliminates the use of traditional grammars where a program is generally composed of statements, each which have their different forms. Commands are far more analogous to function calls, they have a name and the arguments the command is invoked with. Each command offers specific functionality, and can differ in it's results and side effects greatly depending on the arguments supplied to them. 
\par One key concept behind commands is they are executed as they are read from source code, in an interpreted fashion. There is no true compilation of entire documents of source code in Wind. Source code is treated as units of instructions, commands. These are read and executed sequentially. An error occurring does not prevent previous code from properly running:

\begin{verbatim}
wind> push 3 -> out -> push 4 -> out -> c
[ 3 ]
[ 3 4 ]
Error: Expected command symbol, found 'c'
\end{verbatim}

\par This chapter will go over each command, and example use cases. It will also discuss the limitations of each command, and the recommended approach for desired manipulations of data.

\section{push}

\paragraph{  } The most fundamental and often used command in Wind is \emph{push}. The push command has shown up in previous examples in this text, and has the role of appending and writing new data to the end of the active buffer. In Wind, is it one of the two possible ways to add new data into Wind's buffers, the other being the \emph{load} command.
\par The command can be used with none, one, or more arguments. Using the push command with no arguments has no effect, as exemplified below:

\begin{verbatim}
wind> push 1 2 3 -> out
[ 1 2 3 ]
wind> push -> out
[ 1 2 3 ]
\end{verbatim}

\par Attempting to push an incorrectly specified type results in an error. In fact, this is true of any command used in Wind.

\begin{verbatim}
wind> push r
Error: Expected argument or value, found 'r'
\end{verbatim}

\section{out}

\paragraph{  } The \emph{out} command is used to write the current contents of the active buffer to the standard output. It does not use or take any arguments. Internally, it prints each of the data item's string representations. These offer a conversion between the binary representation of Wind data and a human readable version. Every type in Wind has it's own unique string representation. Below are several examples using the \emph{out} command: \\

\begin{verbatim}
wind> out 
[ 3 4 ]
wind> push True False None
wind> out
[ 3 4 True False None ]
wind> push "hello" -> out
[ 3 4 True False None "hello" ]
wind> push + - * / -> out
[ 3 4 True False None "hello" + - * / ]
\end{verbatim}

\section{clr}

\paragraph{  } Perhaps the simplest command in Wind is the \emph{clr} command, also called "clear". It erases the contents of the active buffer and sets the length of it to zero, which allows all of it's space to be reused again. \\

\begin{verbatim}
wind> push 3 4 5 -> out -> clr -> out
[ 3 4 5 ]
[ ]
\end{verbatim}

\par The \emph{clr} command, similar to other commands in Wind, does not error if excess arguments are used. This can be seen below:

\begin{verbatim}
wind> push 3 4 -> clr 4 5 3 -> out
[ ]
\end{verbatim}

\par Part of the reasoning behind this is, if Wind intends to be a high performance language, and work on embedded systems, the flow of computation and data processing should only stop fi absolutely necessary. Errors that would only be caused by the programmer not obeying a specific rule  are not essential to producing intended behavior. Wind changes the idea of safety in a programming language to more pertain to the safety of the runtime, and the platform it runs on, versus keeping track of what the programmer is doing.

\section{map}

\paragraph{  } The map command in Wind maps operations and their arguments to data. It transforms data to change values according to different procedures, such as addition, or logical NOT. Mapping in Wind involves creating and writing a new copy of that data with a transformed value. The exact mechanism for continuous immutable states will be discussed in the next chapter, but for now we can think of mapping as a function:

$$
map(x, s, a_1, \dots, a_n) \longrightarrow y
$$

where $x$ is the target data, $s$ is the symbol, $a_1 \dots a_n$ is the list of arguments, and $y$ is the result data. The above relationship describes the process of a map command for a single data value. Mapping multiple operations and arguments to multiple data values is different, as the question of order arises. In Wind, one can think of the execution of a \emph{map} command as the application of a set of tuples against a set of data:

\begin{align*}
 S_d &= \{d_1,\dots,d_n\} \\
 S_s &= \{ (s_1, a_1,\dots,a_n), \dots,  (s_k, a_1,\dots,a_n)\} \\
 S_r &= S_d \times S_s
\end{align*}

Here, $S_d$ is the initial data set, $S_s$ is the set of tuples of symbols and their arguments, and $S_r$ is the resulting data. The map command execution is really just the multiplication of sets and their members, which can be further simplified to:

$$
map : \mathbb{D} \times \mathbb{S} \longrightarrow \mathbb{R}
$$

\subsection{Usage}

\paragraph{  } To use the \emph{map} command, it can be, as explained previously, paired with tuples of symbols and arguments, to relevant data types:

\begin{verbatim}
wind> push 1 2 3 4
wind> map + 5 | * 3 -> out
[ 18 21 24 27 ]
\end{verbatim}

\par The \emph{map} command can also be used with several other symbols, such as the logical NOT, as well as the exponent symbol:

\begin{verbatim}
wind> push 3 10 10 10       
wind> map ** 2 -> out
[ 9 100 100 100 ]
wind> map * 3 | / 3 6 -> out
[ 1.500 16.667 16.667 16.667 ]
\end{verbatim}

\section{filter}

\paragraph{ } The \emph{filter} command in Wind works similarly to the map command theoretically. Yet, instead of transforming data it performs a test on data, to check whether or not it should retained in the active buffer, or filtered out. The filtering test can best be though of as a boolean function:

$$
F_t: b^k \longrightarrow \{0, 1\}
$$

where $b$ is the input, and $k$ is the \emph{ary} of the function. This means that if the domain of the function is 0, then the result of the function will be constant. However, as that input changes, the arity increases, which makes the output more variable and less certain. Therefore, we can deduce a filtered set of data is:

$$
S_f = \{ x | x  \in S_d \iff F_t(x) = 1 \}
$$

In Wind, when data fails a filter test, it is removed for the active buffer's data. The relationship between how the active and inactive buffer's filter data internally will be discussed later.

\subsection{Usage}

\paragraph{  } In Wind, the \emph{filter} command can be used with two symbols, $>$ and $<$, each representing lesser than or greater than logical operations for numbers. Some examples are as follows:

\begin{verbatim}
wind> push 3 4 5 8 54 20 5 -> out
[ 3 4 5 8 54 20 5 ]
wind> filter < 5 | > 30 -> out
[ ]
wind> push 3 6 8 5
wind> filter > 3 -> out
[ 6 8 5 ]
\end{verbatim}

