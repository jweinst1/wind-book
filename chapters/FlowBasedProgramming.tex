% flow-based programming chapter

\chapter{Flow-based Programming}

\paragraph{Flow-based} programming is a paradigm of programming that deals with the flow of data over one or more destinations. These destinations could in theory be any sort of structure. For this book, and the implementation of \emph{Wind}, they are only considered buffers; fixed sized arrays controlled with pointers and indices. 
\par This chapter will focus on an abstract perspective of flow-based programming. It will describe the fundamental concepts, such as nodes, data, and flows. It will also discuss the arrangements of how data flows can be constructed, and give some respective examples.
\par This chapter serves as an introduction to flow-based programming, and a preparation for the actual Wind language. 

\section{Data}

\paragraph{  } In flow-based programming, data is considered any of the values or information that are computed or processed. Numbers, integers, strings, characters, lists, are all examples of data. Nearly all programming languages type the data that they contain and compute. At the raw level, data to a computer is simply sequences of $1$'s and $0$'s. Programming languages provide much more human readable forms of data. Integers or floats to hold numbers, strings to hold texts, and numerous data structures like a \emph{list} to hold an ordered collection of data.

% mutable vs immutable disc
\par An important distinction in how data is typically assigned types is whether a type is mutable or immutable. An \emph{immutable} type is one that cannot be altered or changed after it is created. In order to alter or change it, you must create a new copy of that immutable type from existing instances of the type. For example, an integer, or any number, is an immutable type. Numbers are created from operations performed on other numbers.

\begin{align*}
a &= 1 \\
b &= a + 1
\end{align*}

\par In the above example, $a$ is a variable with the value of 1, while $b$ is a variable with the value of the sum of $a$ and $1$. Neither of them can be changed. They might be able to be recreated under the same variable name, but this is not altering the existing value. Next, let's look at an example in C that deals with mutable and immutable data.

\begin{lstlisting}[style=numc]
int a = 1;
int* b = malloc(sizeof(int));
*b = a;
\end{lstlisting}

\par Here, $b$ is an integer allocated dynamically on the program's heap, while $a$ is a stack allocated variable. The main difference between them is that, $b$ is a \emph{mutable} data value that can be changed freely after it has been created. Yet $a$ is immutable. The last statement, in the third, line sets the value of $b$ to $a$. This means $b$ can be considered a mutable type. 
\par However, $a$ and $b$ are not both integers. $b$ is a \emph{pointer} to an integer, specifically a block of heap memory the size of one integer. In comparison to dynamically typed languages, $b$ can be thought of as a one element list. In flow-based programming, the same data types have both mutable and immutable characteristics. Which characteristics of data determine it's behavior is determined by the location and the \emph{movement} of the data.

\subsection{Data Movement}

\paragraph{  }Generally, moving data in a program means the ownership of values and data are being passed around. Some languages define specific criteria for the movement of objects and memory, like C++. \emph{Move semantics} usually refers to the process of moving dynamically allocated objects from one owner to another. Here is a simple example.

\begin{lstlisting}[style=numc]
int* a = malloc(sizeof(int) * 2);
a[0] = 1;
a[1] = 2;
int* b = a;
\end{lstlisting}

\par The memory containing enough space for two integers, pointed to by $a$, is passed to $b$. After line four, both $a$ and $b$ point to or "hold" the same value. Accessing through either one yields the same behavior. Changing one of the integers of a changes it in b as well.

\begin{lstlisting}[style=customc]
printf("a is %d %d\n", a[0], a[1]);
printf("b is %d %d\n", b[0], b[1]);
b[0] = 5;
printf("a is %d %d\n", a[0], a[1]);
\end{lstlisting}

\par Compiling this code will display the following in the terminal:

\begin{lstlisting}[style=customc]
1 2
1 2
5 2
\end{lstlisting}

\par Moving the resource always involves sharing or copying a \emph{pointer} or \emph{reference} to some value. Movement never writes the value itself again in a new location. Thus, immutable data cannot be moved in the context of usual move semantics. 
\par In flow-based programming, data is copied from one node or location to another. A reference to data is never moved from owner to owner. During that copy, the data is most often transformed in some way, such that the data written to a new location is not the same as the data in the old location. The following example illustrates how a flow-based program would transform and copy data. \\

\textbf{\emph{Example: Two node transport}}

\begin{lstlisting}[style=numc]

void enterNode(int* node, int arg) {
      *node = arg;
}

void transferToNode(int* startNode, int* endNode, int modify) {
      *endNode = *startNode + modify;
      *startNode = 0;
}

\end{lstlisting}

\par Two functions above are shown, \emph{enterNode} and \emph{transferToNode}. Both of these functions demonstrate the acquisition  and transfer of data between two nodes. It's important to note this is a very basic example. The nodes themselves here do not contain any information of how to "modify" data that they acquire and transfer. The \emph{modify} parameter is simply used as an example of how the next node a data value is transferred to modifies each data point it receives. Take note again that no objects, pointers, or references enter the nodes, only literal data values.

\section{Nodes and Locations}

\paragraph{  } Nodes, destinations, and locations determine the path data will travel in a flow-based program. Nodes which receive, transform, and send data can take on an incredible amount of different forms. The form of a node is usually determined by the functionality or role it plays. While the structure of a node is quite variable, it must always abide by the following rules: \\

\textbf{\emph{Rules of Flow Nodes:}}

\begin{enumerate}
\item \emph{A node must possess some amount of readable and writable memory.}
\item \emph{A node must have a valid memory address that can refer to itself.}
\item \emph{A node must live longer than the data it handles.}
\end{enumerate}

\par The first rule is the least ambiguous. All nodes must be containers, and be able to some non-zero amount of data. Specifically, nodes must own either an array or a pointer to a block of memory. If a node has to transport data along some path, it must be able to hold data temporarily at certain steps. For example, an \codeword{enum} value would not be a valid node, as even though it evaluates to an integer, it is not a container, nor does it possess the ability to own a block of memory.

\par Rule two is quite simple, a node must exist or be allocated in addressable memory. A \emph{register} is not addressable, therefore a register cannot be a valid node. Constants defined with preprocessor statements like \codeerror{#define} do not have a memory address and therefore cannot be used as nodes. Compile-time constants and values can be used as nodes if they are permitted for modification during runtime.